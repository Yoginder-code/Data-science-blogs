<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A comprehensive blog on the four pillars of Object-Oriented Programming (OOP) - Encapsulation, Abstraction, Inheritance, and Polymorphism">
    <meta name="keywords" content="OOP, Object-Oriented Programming, Encapsulation, Abstraction, Inheritance, Polymorphism, Programming Concepts">
    <meta name="author" content="Ace (Yoginder Syal)">
    <title>The Four Pillars of Object-Oriented Programming (OOP)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #b6ce80;
            color: #fff;
            padding: 20px 0;
            text-align: center;
        }
        nav {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center; /* Center the nav items */
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            display: inline-block;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        main {
            padding: 20px;
            max-width: 900px;
            margin: 20px auto;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #333;
        }
        p {
            margin-bottom: 20px;
        }
        code {
            background-color: #eee;
            padding: 5px;
            font-size: 1.1em;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            margin-top: 20px;
        }
        ul {
            padding-left: 20px;
            list-style-type: disc;
        }
    </style>
</head>
<body>

<header>
    <h1>The Four Pillars of Object-Oriented Programming (OOP)</h1>
</header>

<nav>
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#encapsulation">Encapsulation</a></li>
        <li><a href="#abstraction">Abstraction</a></li>
        <li><a href="#inheritance">Inheritance</a></li>
        <li><a href="#polymorphism">Polymorphism</a></li>
        <li><a href="#oop-in-data-science">OOP in Data Science</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
    </ul>
</nav>

<main>
    <section>
        <h2 id="introduction">Introduction</h2>
        <p>Object-Oriented Programming (OOP) is a paradigm that structures programs around objects, which represent real-world entities. It simplifies software development by making it modular, flexible, and scalable. OOP relies on four core concepts: <strong>Encapsulation</strong>, <strong>Abstraction</strong>, <strong>Inheritance</strong>, and <strong>Polymorphism</strong>. Let's explore each concept in detail.</p>
    </section>

    <section>
        <h2 id="encapsulation">1. Encapsulation</h2>
        <img src="encapsulation.png" alt="Encapsulation" style="max-width: 100%; height: auto;">
        <p><strong>Encapsulation</strong> is the bundling of data (attributes) and methods (functions) that operate on the data into a single unit known as a <em>class</em>. It restricts direct access to some of the object's components, which is key for ensuring data integrity.</p>
        <h3>Why Encapsulation?</h3>
        <ul>
            <li><strong>Data Hiding:</strong> By restricting access to variables using access modifiers like <code>private</code>, you prevent unwanted changes to critical data.</li>
            <li><strong>Modularity:</strong> Encapsulation allows each class to act independently, making code more maintainable and reusable.</li>
        </ul>
        <h3>Example in C#:</h3>
        <pre><code class="language-csharp">
// Encapsulation Example
public class BankAccount {
    private double balance;

    public void Deposit(double amount) {
        if(amount > 0) {
            balance += amount;
        }
    }

    public double GetBalance() {
        return balance;
    }
}
        </code></pre>
        <p>In this example, the <code>balance</code> variable is private, meaning it cannot be directly accessed or modified from outside the class. Instead, controlled access is provided through methods like <code>Deposit</code> and <code>GetBalance</code>.</p>
    </section>

    <section>
        <h2 id="abstraction">2. Abstraction</h2>
        <img src="abstraction.png" alt="abstraction" style="max-width: 100%; height: auto;">
        <p><strong>Abstraction</strong> is the process of hiding the complex implementation details of a system and showing only the essential features. It allows developers to work with higher-level functionalities without worrying about the underlying logic.</p>
        <h3>Why Abstraction?</h3>
        <ul>
            <li><strong>Simplicity:</strong> By exposing only necessary methods, abstraction reduces the complexity for users and developers.</li>
            <li><strong>Security:</strong> Hiding sensitive logic ensures that it remains protected from unintended access or manipulation.</li>
        </ul>
        <h3>Example in C#:</h3>
        <pre><code class="language-csharp">
// Abstraction Example
public abstract class Animal {
    public abstract void MakeSound(); // Abstract method
}

public class Dog : Animal {
    public override void MakeSound() {
        Console.WriteLine("Bark");
    }
}
        </code></pre>
        <p>In this example, the abstract class <code>Animal</code> defines an abstract method <code>MakeSound</code>. The specific implementation is left to the subclasses (e.g., <code>Dog</code>), which provide their version of <code>MakeSound</code>.</p>
    </section>

    <section>
        <h2 id="inheritance">3. Inheritance</h2>
        <img src="inheritance.png" alt="inheritance" style="max-width: 100%; height: auto;">
        <p><strong>Inheritance</strong> allows a class to inherit properties and behavior from another class, promoting code reusability. The class that inherits is called the <em>subclass</em> or <em>child class</em>, and the class being inherited from is the <em>superclass</em> or <em>parent class</em>.</p>
        <h3>Why Inheritance?</h3>
        <ul>
            <li><strong>Code Reusability:</strong> Inheritance allows you to create new classes based on existing ones, reducing redundancy.</li>
            <li><strong>Extensibility:</strong> You can easily extend the functionality of a parent class by adding new features to the child class.</li>
        </ul>
        <h3>Example in C#:</h3>
        <pre><code class="language-csharp">
// Inheritance Example
public class Animal {
    public void Eat() {
        Console.WriteLine("This animal is eating.");
    }
}

public class Dog : Animal {
    public void Bark() {
        Console.WriteLine("The dog barks.");
    }
}
        </code></pre>
        <p>In this example, the <code>Dog</code> class inherits the <code>Eat</code> method from the <code>Animal</code> class. Additionally, the <code>Dog</code> class defines its own method <code>Bark</code>.</p>
    </section>

    <section>
        <h2 id="polymorphism">4. Polymorphism</h2>
        <img src="poly.png" alt="polymorphism" style="max-width: 100%; height: auto;">
        <p><strong>Polymorphism</strong> allows objects to be treated as instances of their parent class, enabling a single function to behave differently based on the object it is acting upon. This is achieved through method overriding and method overloading.</p>
        <h3>Why Polymorphism?</h3>
        <ul>
            <li><strong>Flexibility:</strong> You can write more flexible and scalable code that can handle different types of objects in a unified way.</li>
            <li><strong>Maintainability:</strong> Polymorphism allows you to change the behavior of methods in derived classes without affecting the parent class.</li>
        </ul>
        <h3>Example in C# (Method Overriding):</h3>
        <pre><code class="language-csharp">
// Polymorphism Example
public class Animal {
    public virtual void MakeSound() {
        Console.WriteLine("This animal makes a sound.");
    }
}

public class Dog : Animal {
    public override void MakeSound() {
        Console.WriteLine("The dog barks.");
    }
}

public class Cat : Animal {
    public override void MakeSound() {
        Console.WriteLine("The cat meows.");
    }
}
        </code></pre>
        <p>In this example, both <code>Dog</code> and <code>Cat</code> classes override the <code>MakeSound</code> method from the <code>Animal</code> class. This allows for different behaviors based on the specific type of animal.</p>
    </section>

    <section>
        <h2 id="oop-in-data-science">OOP in Data Science</h2>
        <p>OOP principles are also essential in data science, especially when working with machine learning models. For instance:</p>
        <ul>
            <li><strong>Encapsulation:</strong> Models encapsulate the training data and the logic for prediction.</li>
            <li><strong>Abstraction:</strong> Libraries like <code>scikit-learn</code> abstract complex algorithms, allowing users to apply models with simple method calls.</li>
            <li><strong>Inheritance:</strong> New models can inherit from existing classes, allowing for easy customization.</li>
            <li><strong>Polymorphism:</strong> Different models can be treated uniformly through a common interface.</li>
        </ul>
        <h3>Example in Python:</h3>
        <pre><code class="language-python">
from sklearn.ensemble import RandomForestClassifier

# Create an instance of the model
model = RandomForestClassifier()

# Fit the model to the training data
model.fit(X_train, y_train)

# Make predictions
predictions = model.predict(X_test)
        </code></pre>
        <p>In this example, <code>RandomForestClassifier</code> encapsulates the logic for training and prediction, allowing you to use its methods without needing to know the underlying details.</p>
    </section>

    <section>
        <h2 id="conclusion">Conclusion</h2>
        <p>The four pillars of Object-Oriented Programming—Encapsulation, Abstraction, Inheritance, and Polymorphism—are fundamental concepts that enhance code organization, reusability, and maintainability. Understanding these principles is essential for developing efficient software and applying OOP in various domains, including data science and machine learning. By mastering these concepts, developers can build more robust and flexible applications that can adapt to changing requirements.</p>
    </section>
</main>

<footer>
    <p>&copy; 2024 Ace (Yoginder Syal). All Rights Reserved.</p>
</footer>

</body>
</html>
